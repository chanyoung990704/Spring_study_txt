

# Spring 정리

## 영속성 컨테이너

- 데이터베이스와 자바 객체 간 매핑 관리 (상호작용)
- 역할
  - 엔티티 관리:
    - 엔티티 객체 관리
    - 엔티티 상태 변화 추적, 관리 (Life Cycle)
  - 1차 캐시:
    - 데이터베이스에 접근 횟수를 최대한 줄이기 위한 저장 공간
  - 트랜잭션 관리:
    - 트랜잭션 내에서 상태 변화가 이루어짐
    - 커밋 시 데이터베이스에 변경 내용이 반영
      - 이것으로 데이터를 조회하고 수정을 해도 따로 persist할 필요가 없게 된다.
  - 지연 로딩:
    - 즉시 로딩을 할 경우 연관된 모든 데이터를 긁어 모아(join) 가져오기 때문에 많은 양의 데이터와 네트워크 비용 소모.
    - 지연 로딩을 할 경우 필요한 시점에 조회를 하기에 최적화 가능해짐.
  - 변경 감지:
    - 엔티티의 변경 내용을 추적하고 변경된 엔티티만을 DB에 반영
  - 쿼리 생성 및 최적화:
    - JPQL 및 Criteria API를 사용해 쿼리 생성
    - 이에 따른 최적화 기능 사용 가능

## 플러시

- 엔티티의 변경 사항을 데이터베이스에 동기화
- 일반적인 사용 예
  - 트랜잭션 커밋 시
    - 변경된 엔티티 DB에 동기화
  - 명시적 플러시 호출
    - 특정 시점에 DB를 반영하기 위해 개발자가 임의로 플러시 호출, 수행
  - JPQL 및 쿼리 수행
    - DB 조회와 업데이트 사이 불일치를 방지하기 위해 발생
- 유의점
  - 플러시를 호출한 후라고 할 지라도 트랜잭션은 커밋되지 않는다.
    - 트랜잭션 커밋 시에만 영속성 컨테이너의 변경 내용이 실제 DB에 반영된다.

## 준영속 상태

- 영속성 컨테이너에서 관리되던 엔티티가 관리에서 벗어나는 경우
  - 해당 엔티티를 더 이상 추적하거나 DB에 동기화하지 않음을 의미
- 발생 상황
  - 트랜잭션이 종료된 경우
    - 트랜잭션이 커밋되거나 롤백이 되었을 때
  - 엔티티 분리
    - 엔티티 객체를 다른 메소드나 컴포넌트에 전달하거나 DTO를 만들 때
- 준영속 상태를 다시 영속 상태로 만드는 방법
  - Merge
    - 이 경우 수정한 데이터에 공란이 있으면 NULL 값이 부여되기에 객체의 모든 내용을 수정할 필요가 있을 때 사용해야 한다.
  - `.find()`
    - 다시 조회를 해 1차 캐시에 집어 넣는다. 이후는 이전과 같이 사용.

## 프록시

- AOP 및 트랜잭션 관리 기능 구현에 사용
- 다른 객체를 감싸고, 해당 객체 동작을 제어하거나 보완하는 역할 수행
  - 코드의 모듈성, 재사용성, 관리 용이성 향상
- 역할
  - 프록시 객체를 호출하면 실제 대상 객체의 메서드가 실행
  - 프록시를 사용해 부가적 로직을 삽입하거나, 특정 메서드 호출 시 보안 체크, 로깅, 트랜잭션 관리 등 공통 기능 적용
- 종류
  - JDK Dynamic Proxy, CGLIB Proxy
    - (인터페이스 기반), (클래스 기반)
- 장점
  - 중복된 코드를 제거하고 공통된 로직을 한 곳에서 관리 가능
  - 핵심 비즈니스 로직과 부가적인 기능을 분리해 유지 보수성 높일 수 있음
- 주의점
  - 추가적인 오버헤드 발생함을 고려

## 영속성 전이

- 부모 엔티티와 자식 엔티티 관계에서 사용
- 매핑 관계 어노테이션에서 `cascade` 속성을 통해 사용
- 부모 엔티티 상태가 변경되면 자식 엔티티 또한 상태가 변경되게
- 사용 상황
  - 부모 엔티티와 자식 엔티티 함께 작업이 필요할 경우
  - 일관성을 유지하면서 엔티티 상태를 관리할 때

## 고아 객체

- 부모 엔티티에서 특정 자식 엔티티를 삭제할 때 해당 자식 엔

티티도 DB에서 자동으로 삭제되도록 함
- 매핑 관계 어노테이션에서 `orphanRemoval`을 통해 사용